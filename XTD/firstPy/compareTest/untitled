	# Used for counting occurances of foreign key columns
	temporaryCounter = {};

	# In every iteration the name of table is stored in this list. At the end of the iteration I use it to complement columns from value/foreignkeys
	tableNames = [];

	# Dictionary of lists. Values of tables stored in here.
	tableValues = defaultdict(list);

	# Dictionary of dictionaries, attributes of each table stored in here.
	tableAttributes = {};

	listOfEtc = []

	# Iterating from the root
	for elem in xmlTree.iter():
		# Skipping root element
		if elem.tag == xmlTree.getroot().tag:
			continue;

		# Making it lower
		elem.tag = elem.tag.lower();

		# Storing text values
		if elem.text:
			# Only those that are not empty (whitespaces)
			if not elem.text.isspace():
				tableValues[elem.tag].append(makeValueNumber(elem.text));

		# If "-a" is not set, storing attribute values
		if elem.attrib and not optParsed[0]:
			# Element has attribute already
			if elem.tag in tableAttributes:
				for eat in elem.attrib:
					lceat = eat.lower();
					if lceat in tableAttributes[elem.tag]:
						# If element eat exists in tableAttributes, I check if his priority is still the highest
						if tableAttributes[elem.tag][lceat] < makeValueNumberAttr(elem.attrib[eat]):
							# If not, I update the value
							tableAttributes[elem.tag][lceat] = makeValueNumberAttr(elem.attrib[eat]);
					else:
						# Element doesn't exist, therefore I create it
						tableAttributes[elem.tag][lceat] = makeValueNumberAttr(elem.attrib[eat]);
			else:
				# Element doesn't have attributes assigned yet - I assign it actual
				#tableAttributes[elem.tag] = elem.attrib;
				taKeys = elem.attrib.keys();
				tatmpdict = {};
				for tk in taKeys:
					ltk = tk.lower();
					tatmpdict[ltk] = elem.attrib[tk];

				tableAttributes[elem.tag] = tatmpdict;
				
				for key in tableAttributes[elem.tag]:
					tableAttributes[elem.tag][key] = makeValueNumberAttr(tableAttributes[elem.tag][key]);

				print(tableAttributes[elem.tag])


		# browsing the subelements
		for child in elem:
			child.tag = child.tag.lower();			
			# počítač výskytů
			if child.tag in temporaryCounter:
				temporaryCounter[child.tag] += 1;
			else:
				temporaryCounter[child.tag] = 1;


		# položky které se opakovaly nebo neopakovaly (resp. všichni bezprostřední potomci každé tabulky získané z atributů)
		tmpCntKeys = temporaryCounter.keys();

		for key in tmpCntKeys:
			occurences = temporaryCounter[key]
			if occurences > int(optParsed[7]):
				listOfEtc.append([key, elem.tag])
				if elem.tag+"_id INT" not in d[key]:
					d[key].append(elem.tag+"_id INT")
				maxOcc = occurences 
				while maxOcc:
					try:
						d[elem.tag].remove(key+str(maxOcc)+"_id INT")
					except ValueError:
						maxOcc = maxOcc;
					if maxOcc == 1:
						try:
							d[elem.tag].remove(key+"_id INT")
						except ValueError:
							maxOcc = maxOcc
					int(maxOcc)
					maxOcc -= 1
				# vetev, kde jde rodic do tabulky ditete
			else:
				if listOfEtc.count([key, elem.tag]) == 0:
					i = 0;
					while i < temporaryCounter[key]:
						if temporaryCounter[key] == 1:
							outTagName = str(key)+"_id INT";
							if outTagName not in d[elem.tag]:
								d[elem.tag].append(outTagName);
							if str(key)+"1_id INT" in d[elem.tag]:
								try:
									d[elem.tag].remove(str(key)+"_id INT")
								except ValueError:
									key = key
						else:
							outTagName = str(key)+""+str(i+1)+"_id INT";
							if outTagName not in d[elem.tag]:
								d[elem.tag].append(outTagName);
						i+=1;

		temporaryCounter.clear();

		tableNames.append(elem.tag);

	for tItem in tableNames:
		dKeys = d.keys();
		if tItem not in dKeys:
			d[tItem] = None;